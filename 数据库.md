## 数据库系统原理

### 1. 基础知识

#### 相关概念

**四个基本概念**

- **数据（Data）**：数据描述事物的符号记录；常见的种类有：文本，图形，图像，音频，视频等；特点是：数据与其语义是不可分的。
- **数据库（Database）**：是长期存储在计算机内、有组织的、可共享的大量数据的集合。基本特征：可共享，冗余度较小，数据独立性较高，易扩展，数据按照一定的模型组织、描述和存储。
- **数据库管理系统（DBMS）**：位于用户和操作系统之间的一层数据管理软件。主要功能：数据定义功能，数据组织、存储和管理，数据操纵功能，数据库的事物管理和运行管理，数据库的建立和维护功能。
- **数据库系统（Database System）**：是由数据库，数据库管理系统，应用系统和数据库管理人员组成的存储、管理、处理和维护数据的系统。

**数据库系统的特点：**数据结构化，数据共享性高、冗余度低、易扩充，数据独立性高，数据由DBMS统一管理和控制。

**关于码的概念**：

- **候选码**：若关系中的某一属性组的值能唯一地标识一个元组， 则称该属性组为候选码  
- **全码**：关系模式的所有属性组是这个关系模式的候选码， 称为全码  
- **主码**：若一个关系有多个候选码， 则选定其中一个为主码  
- **外码**：设F是基本关系R的一个或一组属性， F不是关系R的码，但F是另一个关系的码， 则称F是基本关系R的外码  
- 候选码的每个属性都是主属性，不包含在任何侯选码中的属性称为非主属性或非码属性

**基本关系的性质**：

1. 列是同质的，即每一列中的分量是同类型数据，来自同一个域
2. 不同的列可能来自同一个域
3. 列的顺序无所谓，列的次序可以任意交换
4. 行的顺序无所谓，行的次序可以任意交换
5. 任意连个元组的候选码不能相同
6. 分量必须是原子值

**关系的完整性**：

- 实体完整性：若属性A是关系R的主属性，则A不能取空值
- 参照完整性：若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为空值或者等于S中某个元组的主码值    
- 用户定义完整性：针对某一具体关系数据库的约束条件， 反映某一具体应用所涉及的数据必须满足的语义要求  

#### 数据模型

常用数据模型：非关系模型（包括层次模型、网状模型），关系模型，面向对象模型，对象关系模型。

**层次模型**

层次模型需要满足以下两个基本条件：

1. 有且只有一个节点没有双亲节点，这个节点称为根节点。
2. 根以外的节点有且只有一个双亲节点。

**网状模型**

网状模型需要满足以下两个基本条件：

1. 允许一个以上的节点无双亲
2. 一个节点可以有多于一个的双亲

**关系模型**

相关概念：

> 关系：一个关系对应一张表
>
> 元组：表中的一行即为一个元组
>
> 属性：表中的一列即为一个属性
>
> 主码：表中的一个属性组，可以唯一确定一个元组
>
> 域：属性的取值范围
>
> 分量：元组中的一个属性值

关系的完整性约束条件：实体完整性，参照完整性，用户定义的完整性

### 2. 关系数据理论

<div>
    <table style="text-align: center;width:450px">
        <tr>
            <th>column1</th>
            <th>column2</th>
            <th>column3</th>
        </tr>
        <tr>
            <td>value1</td>
            <td>value2</td>
            <td>value3</td>
        </tr>
    </table>
</div>

#### 2.1 数据依赖

1. **函数依赖**

    记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。

    如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。

    对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是**部分函数依赖**，否则就是完全函数依赖。

    对于 A->B，B->C，则 A->C 是一个**传递函数依赖**。

2. **多值依赖**：

**数据依赖带来的问题**：

| Sno  | Sname  | Sdept  | Mname  | Cname  | Grade |
| :--: | :----: | :----: | :----: | :----: | :---: |
|  1   | 学生-1 | 学院-1 | 院长-1 | 课程-1 |  90   |
|  2   | 学生-2 | 学院-2 | 院长-2 | 课程-2 |  80   |
|  2   | 学生-2 | 学院-2 | 院长-2 | 课程-1 |  100  |
|  3   | 学生-3 | 学院-2 | 院长-2 | 课程-2 |  95   |

- 数据冗余：如上表院长-2重复出现
- 修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改
- 插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入
- 删除异常：删除一个信息，那么也会丢失其它信息。例如删除了课程-1需要删除第一行和第三行，那么学生-1的信息就会丢失。

#### 2.2 范式

##### 1NF

如果关系模式R的**所有属性都是不可分的基本数据项**，则R∈ 1NF  

##### 2NF

若R∈ 1NF， 且**每一个非主属性完全函数依赖于码**， 则R∈ 2NF 

可以采用投影分解法将一个1NF的关系分解为多个2NF的关系，从一定程度上减轻1NF关系中存在的问题，但不能完全消除这些问题。

##### 3NF

若R∈ 2NF，且**每一个非主属性不传递依赖于码**(这使得非主属性之间不存在函数依赖)，则R∈ 3NF。

##### BCNF

若关系R的**每一个决定因素都包含码**，那么R∈ BCNF。

**并不是规范化程度越高， 模式就越好**，必须结合应用环境和现实世界的具体情况合理地选择数据库模式。  

### 3. 事务

#### 3.1 概念

事务是逻辑上的一组操作，要么都执行，要么都不执行。

**典型的MySQL事务是如下操作**：

```mysql
start transaction;
……  #一条或多条sql语句
commit;
```

​	其中 start transaction 标识事务开始，commit 提交事务，将执行结果写入到数据库。如果 sql 语句执行出现问题，会调用rollback，回滚所有已经执行成功的 sql 语句。

​	MySQL中默认采用的是自动提交（autocommit）模式，**如果没有 start transaction 显式地开始一个事务，那么每个 sql 语句都会被当做一个事务执行提交操作**。可以通过 `set autocommit = 0;` 来关闭自动提交，但是需要注意的是 **autocommit 参数是针对连接的，在一个连接中修改了参数，不会对其他连接产生影响**。

#### 3.2 事务的特点(ACID)

1. **原⼦性（Atomicity）**：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
2. **⼀致性（Consistency）**：事务执行结束后，**数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态**。
3. **隔离性（Isolation）**：一个事务的内部操作和使用的数据对其他并发的事务是隔离的，并发执行的各个事务之间不能相互干扰。
4. **持久性（Durability）**：一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。

事务的**隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现**。

#### 3.3 事务日志

- **redo log（重做日志）** 实现持久性

    > ​	InnoDB 作为 MySQL 的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘 IO，效率会很低。为此，InnoDB 提供了缓存（`Buffer Pool`），`Buffer Pool`中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从`Buffer Pool`中读取，如果`Buffer Pool`中没有，则从磁盘读取后放入`Buffer Pool`；当向数据库写入数据时，会首先写入`Buffer Pool`，`Buffer Pool`中修改的数据会定期刷新到磁盘中，这一过程称为“刷脏”。`Buffer Pool`的使用大大提高了读写数据的效率，但是也带了新的问题：如果 MySQL 宕机，而此时`Buffer Pool`中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。

    ​	`redo log` 包含两部分：一是内存中的日志缓冲，二是磁盘上的重做日志文件(`redo log file`)。**事务开启时**，事务中的操作，都会**先写入存储引擎的日志缓冲中**，在**事务提交之前**，这些**缓冲的日志都需要提前刷新到磁盘上持久化**，当事务提交之后，在`Buffer Pool`中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据`redo log`中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。

    ​	`redo log`是以顺序追加的方式记录的，所有的事务共享`redo log`的存储空间，它们的`redo log`按语句的执行顺序，依次交替的记录在一起。

- **undo log（回滚日志）** 实现原子性

    回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可

​    `redo log`是恢复提交事务修改的页操作，而`undo log`是回滚行记录到特定版本。二者记录的内容也不同，`redo log`是物理日志，记录页的物理修改操作，而`undo log`是逻辑日志，根据每行记录进行记录。

**其他类型日志**：

- **错误日志**：记录出错信息，也记录一些警告信息或者正确的信息。
- **查询日志**：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。
- **慢查询日志**：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。
- **二进制日志**：记录对数据库执行更改的所有操作。

#### 3.4 MySQL的分布式事务

<img src="https://gitee.com/coldsun233/NotePic/raw/master/img/MySQL%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B.png" style="zoom:70%;" />

如图，MySQL 的分布式事务模型。模型中分三块：应用程序（AP）、资源管理器（RM）、事务管理器（TM）:

- 应用程序：定义了事务的边界，指定需要做哪些事务；
- 资源管理器：提供了访问事务的方法，通常一个数据库就是一个资源管理器；
- 事务管理器：协调参与了全局事务中的各个事务。

分布式事务采用两段式提交（`two-phase commit`）的方式：

- 第一阶段所有的事务节点开始准备，告诉事务管理器`ready`。
- 第二阶段事务管理器告诉每个节点是`commit`还是`rollback`。如果有一个节点失败，就需要全局的节点全部`rollback`，以此保障事务的原子性。

#### 3.5 并发事务存在的问题

- **丢失修改**：在⼀个事务读取⼀个数据时，另外⼀个事务也访问了该数据，那么在第⼀个事务中修改了这个数据后，第⼆个事务也修改了这个数据。这样第⼀个事务内的修改结果就被丢失，因此称为丢失修改。  
- **脏读**：事务A修改了数据但未提交，这时事务B读取了该数据，然后事务A回滚操作，那么事务B读取到的数据是脏数据。
- **不可重复读**：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
- **幻读**：一个事务A读取了某个范围的数据，接着另一个并发事务B在这个范围内插入了一些数据，在随后的查询中，事务A就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

产生并发不一致性问题的主要原因是破坏了事务的隔离性，**解决方法是通过并发控制来保证隔离性**。

#### 3.6 事务隔离级别

  <div>
    <table style="text-align: center;width:650px">
        <caption style="font-weight:800;">隔离级别能解决的并发一致性问题</caption>
        <tr>
            <th>隔离级别</th>
            <th>脏读</th>
            <th>不可重复读</th>
            <th>幻读</th>
        </tr>
        <tr>
            <td>读未提交</td>
            <td>×</td>
            <td>×</td>
            <td>×</td>
        </tr>
        <tr>
            <td>读已提交</td>
            <td>√</td>
            <td>×</td>
            <td>×</td>
        </tr>
        <tr>
            <td>可重复读</td>
            <td>√</td>
            <td>√</td>
            <td>×</td>
        </tr>
        <tr>
            <td>可串行化</td>
            <td>√</td>
            <td>√</td>
            <td>√</td>
        </tr>
    </table>
</div>

- **READ-UNCOMMITTED（读未提交）**：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
- **READ-COMMITTED（读已提交）**：允许读取并发事务已经提交的数据，可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣。
- **REPEATABLE-READ（可重复读）**：对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改，可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。==**MySQL的默认事务隔离级别**==
- **SERIALIZABLE（可串行化）**：最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说，该级别可以防⽌脏读、不可重复读以及幻读。 

> InnoDB 存储引擎在 **REPEATABLE-READ**（可重复读）事务隔离级别下使用的是 [Next-Key Lock](#nextKeyLock) 算法，可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。

### 4. 并发控制

#### 4.1 锁

##### 锁的分类

**按对数据操作的类型分**

- **排他锁（x锁，也称为写锁）**：当前写操作没有完成前，它会阻断其他写锁和读锁。**在更新操作(INSERT、UPDATE 或 DELETE)过程中始终应用排它锁**。
- **共享锁（s锁，也称为读锁）**：针对同一份数据，多个读操作可以同时进行，不会互相影响。

一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

​	**上共享锁的写法**：select ... lock in share mode

​		例如： select  * from table where id=1 lock in share mode；

​	**上排它锁的写法**：select ... for update

​		例如：select * from table where id=1 for update；

**按对数据操作的粒度分**

- **表级锁**：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）。
- **行级锁**：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）。
- **页面锁**：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

##### MyISAM的锁

MyISAM 的表锁有两种模式：

- 表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求。
- 表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作。

默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求。

##### InnoDB的锁

InnoDB的行锁同样也分为共享锁和排他锁。

**注意：行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了**。

```sql
# 明确指定主键，并且有此笔资料，row lock
SELECT * FROM tablename WHERE id='3' FOR UPDATE;

# 明确指定主键，若查无此笔资料，无lock
SELECT * FROM tablename WHERE id='-1' FOR UPDATE;

# 无主键，table lock
SELECT * FROM tablename WHERE name='jojo' FOR UPDATE;

# 主键不明确，table lock
SELECT * FROM tablename WHERE id<>'3' FOR UPDATE;
```

​    用索引字段做为条件进行修改时， **是否表锁的取决于这个索引字段能否确定记录唯一**，当索引值对应记录不唯一，会进行锁表，相反则行锁。

**InnoDB的三种行锁算法**

1. **记录锁(Record Locks)**：单个行记录上的锁。对索引项加锁，而不是对记录本身加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。

    在通过 **主键索引** 与 **==唯一==索引** 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁。

2. **间隙锁（Gap Locks）**：当使用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做“间隙”。InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。只会锁定索引之间的间隙，但是不包含索引本身。

    例如：

    ```sql
    SELECT * FROM table WHERE id BETWEN 1 AND 10 FOR UPDATE;
    ```

    所有在`（1，10）`区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。

3. <span id="nextKeyLock">**临键锁(Next-key Locks)**</span>：**临键锁**，是**记录锁与间隙锁的组合**，它的封锁范围，既包含索引记录，又包含索引区间。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, 20，那么就需要锁定以下区间：

    ```javascript
    (-∞, 10]、(10, 11]、(11, 13]、(13, 20]、(20, +∞)
    ```

    当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围；当查询的索引为辅助索引时，默认使用Next-Key Locking技术进行加锁，锁定范围是前一个索引到后一个索引之间范围。

InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是**表锁**：

- 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。
- 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。

​    任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁。IX，IS是表级锁，不会和行级的X，S锁发生冲突，只会和表级的X，S发生冲突。

​    如果没有意向锁，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。

##### 封锁协议

- **一级封锁协议**：事务 T 要修改数据 A 时必须加 X 锁，**直到 T 结束才释放锁**（结束包括正常结束`commit`和非正常结束`rollback`）。可以解决丢失修改问题，但不能解决不可重复读和脏读的问题。
- **二级封锁协议**：在一级的基础上，要求事务 T 读取数据 A 时必须加 S 锁，**读取完马上释放** S 锁。可以解决丢失修改和脏读（如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据）的问题，不能解决不可重复读的问题。
- **三级封锁协议**：在一级的基础上，要求读取数据 A 时必须加 S 锁，**直到事务结束**了才能释放 S 锁。可以解决丢失修改、脏读、不可重复读（事务 T 对数据 A 加了 S 锁，其他事务只能对 A 加 S 锁而不能加 X 锁，即其他事务只能读取 A 而不能修改它，只能等到事务 T 结束）的问题。

##### 死锁和活锁

**死锁**是指两个或多个事务都已经封锁了一些数据对象，然后又都请求锁定其他事务已封锁的数据对象，从而导致循环等待。

解决死锁的方法：

- 死锁的预防

    1. 一次性封锁法：要求事务一次性将所有数据全部加锁。存在问题：降低了系统的并发性、难以精确的确定所有的数据对象
    2. 顺序封锁法：对数据对象规定一个封锁顺序，所有事务都按照这个顺序封锁。存在问题：维护成本高、很难实现

- 死锁的诊断和解除

    诊断采用超时法或等待图法。

    解除：选择一个处理死锁代价最小的事务， 将其撤消释放此事务持有的所有的锁， 使其它事务能继续运行下去  

事务T1封锁了数据R，事务T2又请求封锁R，于是T2等待；T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待；T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求……T2有可能永远等待， 这就是**活锁**的情形。

避免活锁的简单方法是采用先来先服务策略。  

##### 乐观锁和悲观锁

锁会“乐观地”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务。

悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁。

#### 4.2 MVCC 多版本并发控制

​	多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现 读已提交 和 可重复读 这两种隔离级别，**MVCC也只在这两种隔离级别下工作**。

​	MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事物看到的数据都是一致的。

## MySQL

## SQL






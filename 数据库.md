## 数据库系统原理

### 1. 基础知识

#### 相关概念

**四个基本概念**

- **数据（Data）**：数据描述事物的符号记录；常见的种类有：文本，图形，图像，音频，视频等；特点是：数据与其语义是不可分的。
- **数据库（Database）**：是长期存储在计算机内、有组织的、可共享的大量数据的集合。基本特征：可共享，冗余度较小，数据独立性较高，易扩展，数据按照一定的模型组织、描述和存储。
- **数据库管理系统（DBMS）**：位于用户和操作系统之间的一层数据管理软件。主要功能：数据定义功能，数据组织、存储和管理，数据操纵功能，数据库的事物管理和运行管理，数据库的建立和维护功能。
- **数据库系统（Database System）**：是由数据库，数据库管理系统，应用系统和数据库管理人员组成的存储、管理、处理和维护数据的系统。

**数据库系统的特点：**数据结构化，数据共享性高、冗余度低、易扩充，数据独立性高，数据由DBMS统一管理和控制。

**关于码的概念**：

- **候选码**：若关系中的某一属性组的值能唯一地标识一个元组， 则称该属性组为候选码  
- **全码**：关系模式的所有属性组是这个关系模式的候选码， 称为全码  
- **主码**：若一个关系有多个候选码， 则选定其中一个为主码  
- **外码**：设F是基本关系R的一个或一组属性， F不是关系R的码，但F是另一个关系的码， 则称F是基本关系R的外码  
- 候选码的每个属性都是主属性，不包含在任何侯选码中的属性称为非主属性或非码属性

**基本关系的性质**：

1. 列是同质的，即每一列中的分量是同类型数据，来自同一个域
2. 不同的列可能来自同一个域
3. 列的顺序无所谓，列的次序可以任意交换
4. 行的顺序无所谓，行的次序可以任意交换
5. 任意连个元组的候选码不能相同
6. 分量必须是原子值

**关系的完整性**：

- 实体完整性：若属性A是关系R的主属性，则A不能取空值
- 参照完整性：若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为空值或者等于S中某个元组的主码值    
- 用户定义完整性：针对某一具体关系数据库的约束条件， 反映某一具体应用所涉及的数据必须满足的语义要求  

#### 数据模型

常用数据模型：非关系模型（包括层次模型、网状模型），关系模型，面向对象模型，对象关系模型。

**层次模型**

层次模型需要满足以下两个基本条件：

1. 有且只有一个节点没有双亲节点，这个节点称为根节点。
2. 根以外的节点有且只有一个双亲节点。

**网状模型**

网状模型需要满足以下两个基本条件：

1. 允许一个以上的节点无双亲
2. 一个节点可以有多于一个的双亲

**关系模型**

相关概念：

> 关系：一个关系对应一张表
>
> 元组：表中的一行即为一个元组
>
> 属性：表中的一列即为一个属性
>
> 主码：表中的一个属性组，可以唯一确定一个元组
>
> 域：属性的取值范围
>
> 分量：元组中的一个属性值

关系的完整性约束条件：实体完整性，参照完整性，用户定义的完整性

### 2. 关系数据理论

<div>
    <table style="text-align: center;width:450px">
        <tr>
            <th>column1</th>
            <th>column2</th>
            <th>column3</th>
        </tr>
        <tr>
            <td>value1</td>
            <td>value2</td>
            <td>value3</td>
        </tr>
    </table>
</div>

#### 2.1 数据依赖

1. **函数依赖**

    记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。

    如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。

    对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是**部分函数依赖**，否则就是完全函数依赖。

    对于 A->B，B->C，则 A->C 是一个**传递函数依赖**。

2. **多值依赖**：

**数据依赖带来的问题**：

| Sno  | Sname  | Sdept  | Mname  | Cname  | Grade |
| :--: | :----: | :----: | :----: | :----: | :---: |
|  1   | 学生-1 | 学院-1 | 院长-1 | 课程-1 |  90   |
|  2   | 学生-2 | 学院-2 | 院长-2 | 课程-2 |  80   |
|  2   | 学生-2 | 学院-2 | 院长-2 | 课程-1 |  100  |
|  3   | 学生-3 | 学院-2 | 院长-2 | 课程-2 |  95   |

- 数据冗余：如上表院长-2重复出现
- 修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改
- 插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入
- 删除异常：删除一个信息，那么也会丢失其它信息。例如删除了课程-1需要删除第一行和第三行，那么学生-1的信息就会丢失。

#### 2.2 范式

##### 1NF

如果关系模式R的**所有属性都是不可分的基本数据项**，则R∈ 1NF  

##### 2NF

若R∈ 1NF， 且**每一个非主属性完全函数依赖于码**， 则R∈ 2NF 

可以采用投影分解法将一个1NF的关系分解为多个2NF的关系，从一定程度上减轻1NF关系中存在的问题，但不能完全消除这些问题。

##### 3NF

若R∈ 2NF，且**每一个非主属性不传递依赖于码**(这使得非主属性之间不存在函数依赖)，则R∈ 3NF。

##### BCNF

若关系R的**每一个决定因素都包含码**，那么R∈ BCNF。

**并不是规范化程度越高， 模式就越好**，必须结合应用环境和现实世界的具体情况合理地选择数据库模式。  

### 3. 事务

#### 3.1 概念

事务是逻辑上的一组操作，要么都执行，要么都不执行。

**典型的MySQL事务是如下操作**：

```mysql
start transaction;
……  #一条或多条sql语句
commit;
```

​	其中 start transaction 标识事务开始，commit 提交事务，将执行结果写入到数据库。如果 sql 语句执行出现问题，会调用rollback，回滚所有已经执行成功的 sql 语句。

​	MySQL中默认采用的是自动提交（autocommit）模式，**如果没有 start transaction 显式地开始一个事务，那么每个 sql 语句都会被当做一个事务执行提交操作**。可以通过 `set autocommit = 0;` 来关闭自动提交，但是需要注意的是 **autocommit 参数是针对连接的，在一个连接中修改了参数，不会对其他连接产生影响**。

#### 3.2 事务的特点(ACID)

1. **原⼦性（Atomicity）**：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
2. **⼀致性（Consistency）**：事务执行结束后，**数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态**。
3. **隔离性（Isolation）**：一个事务的内部操作和使用的数据对其他并发的事务是隔离的，并发执行的各个事务之间不能相互干扰。
4. **持久性（Durability）**：一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。

事务的**隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现**。

#### 3.3 事务日志

- **redo log（重做日志）** 实现持久性

    > ​	InnoDB 作为 MySQL 的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘 IO，效率会很低。为此，InnoDB 提供了缓存（`Buffer Pool`），`Buffer Pool`中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从`Buffer Pool`中读取，如果`Buffer Pool`中没有，则从磁盘读取后放入`Buffer Pool`；当向数据库写入数据时，会首先写入`Buffer Pool`，`Buffer Pool`中修改的数据会定期刷新到磁盘中，这一过程称为“刷脏”。`Buffer Pool`的使用大大提高了读写数据的效率，但是也带了新的问题：如果 MySQL 宕机，而此时`Buffer Pool`中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。

    ​	`redo log` 包含两部分：一是内存中的日志缓冲，二是磁盘上的重做日志文件(`redo log file`)。**事务开启时**，事务中的操作，都会**先写入存储引擎的日志缓冲中**，在**事务提交之前**，这些**缓冲的日志都需要提前刷新到磁盘上持久化**，当事务提交之后，在`Buffer Pool`中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据`redo log`中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。

    ​	`redo log`是以顺序追加的方式记录的，所有的事务共享`redo log`的存储空间，它们的`redo log`按语句的执行顺序，依次交替的记录在一起。

- **undo log（回滚日志）** 实现原子性

    回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可

​    `redo log`是恢复提交事务修改的页操作，而`undo log`是回滚行记录到特定版本。二者记录的内容也不同，`redo log`是物理日志，记录页的物理修改操作，而`undo log`是逻辑日志，根据每行记录进行记录。

**其他类型日志**：

- **错误日志**：记录出错信息，也记录一些警告信息或者正确的信息。
- **查询日志**：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。
- **慢查询日志**：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。
- **二进制日志**：记录对数据库执行更改的所有操作。

#### 3.4 MySQL的分布式事务

<img src="https://gitee.com/coldsun233/NotePic/raw/master/img/MySQL%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B.png" style="zoom:70%;" />

如图，MySQL 的分布式事务模型。模型中分三块：应用程序（AP）、资源管理器（RM）、事务管理器（TM）:

- 应用程序：定义了事务的边界，指定需要做哪些事务；
- 资源管理器：提供了访问事务的方法，通常一个数据库就是一个资源管理器；
- 事务管理器：协调参与了全局事务中的各个事务。

分布式事务采用两段式提交（`two-phase commit`）的方式：

- 第一阶段所有的事务节点开始准备，告诉事务管理器`ready`。
- 第二阶段事务管理器告诉每个节点是`commit`还是`rollback`。如果有一个节点失败，就需要全局的节点全部`rollback`，以此保障事务的原子性。

#### 3.5 并发事务存在的问题

- **丢失修改**：在⼀个事务读取⼀个数据时，另外⼀个事务也访问了该数据，那么在第⼀个事务中修改了这个数据后，第⼆个事务也修改了这个数据。这样第⼀个事务内的修改结果就被丢失，因此称为丢失修改。  
- **脏读**：事务A修改了数据但未提交，这时事务B读取了该数据，然后事务A回滚操作，那么事务B读取到的数据是脏数据。
- **不可重复读**：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
- **幻读**：一个事务A读取了某个范围的数据，接着另一个并发事务B在这个范围内插入了一些数据，在随后的查询中，事务A就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

产生并发不一致性问题的主要原因是破坏了事务的隔离性，**解决方法是通过并发控制来保证隔离性**。

#### 3.6 事务隔离级别

  <div>
    <table style="text-align: center;width:650px">
        <caption style="font-weight:800;">隔离级别能解决的并发一致性问题</caption>
        <tr>
            <th>隔离级别</th>
            <th>脏读</th>
            <th>不可重复读</th>
            <th>幻读</th>
        </tr>
        <tr>
            <td>读未提交</td>
            <td>×</td>
            <td>×</td>
            <td>×</td>
        </tr>
        <tr>
            <td>读已提交</td>
            <td>√</td>
            <td>×</td>
            <td>×</td>
        </tr>
        <tr>
            <td>可重复读</td>
            <td>√</td>
            <td>√</td>
            <td>×</td>
        </tr>
        <tr>
            <td>可串行化</td>
            <td>√</td>
            <td>√</td>
            <td>√</td>
        </tr>
    </table>
</div>

- **READ-UNCOMMITTED（读未提交）**：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
- **READ-COMMITTED（读已提交）**：允许读取并发事务已经提交的数据，可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣。
- **REPEATABLE-READ（可重复读）**：对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改，可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。==**MySQL的默认事务隔离级别**==
- **SERIALIZABLE（可串行化）**：最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说，该级别可以防⽌脏读、不可重复读以及幻读。 

> InnoDB 存储引擎在 **REPEATABLE-READ**（可重复读）事务隔离级别下使用的是 [Next-Key Lock](#nextKeyLock) 算法，可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。

### 4. 并发控制

#### 4.1 锁

##### 锁的分类

**按对数据操作的类型分**

- **排他锁（x锁，也称为写锁）**：当前写操作没有完成前，它会阻断其他写锁和读锁。**在更新操作(INSERT、UPDATE 或 DELETE)过程中始终应用排它锁**。
- **共享锁（s锁，也称为读锁）**：针对同一份数据，多个读操作可以同时进行，不会互相影响。

一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

​	**上共享锁的写法**：select ... lock in share mode

​		例如： select  * from table where id=1 lock in share mode；

​	**上排它锁的写法**：select ... for update

​		例如：select * from table where id=1 for update；

**按对数据操作的粒度分**

- **表级锁**：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）。
- **行级锁**：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）。
- **页面锁**：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

##### MyISAM的锁

MyISAM 的表锁有两种模式：

- 表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求。
- 表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作。

默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求。

##### InnoDB的锁

InnoDB的行锁同样也分为共享锁和排他锁。

**注意：行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了**。

```sql
# 明确指定主键，并且有此笔资料，row lock
SELECT * FROM tablename WHERE id='3' FOR UPDATE;

# 明确指定主键，若查无此笔资料，无lock
SELECT * FROM tablename WHERE id='-1' FOR UPDATE;

# 无主键，table lock
SELECT * FROM tablename WHERE name='jojo' FOR UPDATE;

# 主键不明确，table lock
SELECT * FROM tablename WHERE id<>'3' FOR UPDATE;
```

​    用索引字段做为条件进行修改时， **是否表锁的取决于这个索引字段能否确定记录唯一**，当索引值对应记录不唯一，会进行锁表，相反则行锁。

**InnoDB的三种行锁算法**

1. **记录锁(Record Locks)**：单个行记录上的锁。对索引项加锁，而不是对记录本身加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。

    在通过 **主键索引** 与 **==唯一==索引** 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁。

2. **间隙锁（Gap Locks）**：当使用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做“间隙”。InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。只会锁定索引之间的间隙，但是不包含索引本身。

    例如：

    ```sql
    SELECT * FROM table WHERE id BETWEN 1 AND 10 FOR UPDATE;
    ```

    所有在`（1，10）`区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。

3. <span id="nextKeyLock">**临键锁(Next-key Locks)**</span>：**临键锁**，是**记录锁与间隙锁的组合**，它的封锁范围，既包含索引记录，又包含索引区间。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, 20，那么就需要锁定以下区间：

    ```javascript
    (-∞, 10]、(10, 11]、(11, 13]、(13, 20]、(20, +∞)
    ```

    当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围；当查询的索引为辅助索引时，默认使用Next-Key Locking技术进行加锁，锁定范围是前一个索引到后一个索引之间范围。

InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是**表锁**：

- 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。
- 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。

​    任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁。IX，IS是表级锁，不会和行级的X，S锁发生冲突，只会和表级的X，S发生冲突。

​    如果没有意向锁，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。

##### 封锁协议

- **一级封锁协议**：事务 T 要修改数据 A 时必须加 X 锁，**直到 T 结束才释放锁**（结束包括正常结束`commit`和非正常结束`rollback`）。可以解决丢失修改问题，但不能解决不可重复读和脏读的问题。
- **二级封锁协议**：在一级的基础上，要求事务 T 读取数据 A 时必须加 S 锁，**读取完马上释放** S 锁。可以解决丢失修改和脏读（如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据）的问题，不能解决不可重复读的问题。
- **三级封锁协议**：在一级的基础上，要求读取数据 A 时必须加 S 锁，**直到事务结束**了才能释放 S 锁。可以解决丢失修改、脏读、不可重复读（事务 T 对数据 A 加了 S 锁，其他事务只能对 A 加 S 锁而不能加 X 锁，即其他事务只能读取 A 而不能修改它，只能等到事务 T 结束）的问题。

##### 死锁和活锁

**死锁**是指两个或多个事务都已经封锁了一些数据对象，然后又都请求锁定其他事务已封锁的数据对象，从而导致循环等待。

解决死锁的方法：

- 死锁的预防

    1. 一次性封锁法：要求事务一次性将所有数据全部加锁。存在问题：降低了系统的并发性、难以精确的确定所有的数据对象
    2. 顺序封锁法：对数据对象规定一个封锁顺序，所有事务都按照这个顺序封锁。存在问题：维护成本高、很难实现

- 死锁的诊断和解除

    诊断采用超时法或等待图法。

    解除：选择一个处理死锁代价最小的事务， 将其撤消释放此事务持有的所有的锁， 使其它事务能继续运行下去  

事务T1封锁了数据R，事务T2又请求封锁R，于是T2等待；T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待；T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求……T2有可能永远等待， 这就是**活锁**的情形。

避免活锁的简单方法是采用先来先服务策略。  

##### 乐观锁和悲观锁

锁会“乐观地”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务。

悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁。

#### 4.2 MVCC 多版本并发控制

​	多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现 读已提交 和 可重复读 这两种隔离级别，**MVCC也只在这两种隔离级别下工作**。

​	MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事物看到的数据都是一致的。

<!-- 分页-->

<div style="page-break-after: always;"></div>

<!--分页-->

## MySQL

### 1. MySQL 架构

- **连接层**：最上层是一些客户端和连接服务。**主要完成一些类似于连接处理、授权认证、及相关的安全方案**。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。
- **服务层**：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等。
- **引擎层**：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。
- **存储层**：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互。

<img src="https://gitee.com/coldsun233/NotePic/raw/master/img/MySQL%E6%9E%B6%E6%9E%84.webp" style="zoom:70%;" />

**一条 SQL 语句在 MySQL 中的执行流程**
客户端请求 $\dashrightarrow$ 连接器（验证用户身份，给予权限）$\dashrightarrow$ 查询缓存（存在缓存则直接返回，否则继续执行后续操作）$\dashrightarrow$ 分析器（对 SQL 进行语法分析和词法分析）$\dashrightarrow$ 优化器（对执行的 sql 优化，选择最优的执行方案方法）$\dashrightarrow$ 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）$\dashrightarrow$ 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）

### 2. MySQL存储引擎

<img src="https://gitee.com/coldsun233/NotePic/raw/master/img/mysql%E5%BC%95%E6%93%8E.png" style="zoom:100%;" />

常见的存储引擎就 InnoDB、MyISAM、Memory

#### MyISAM 和 InnoDB 对比

1. InnoDB 支持事务，MyISAM 不支持事务；
2. InnoDB 支持外键，MyISAM 不支持；
3. InnoDB 是聚簇索引，MyISAM 是非聚簇索引。**聚簇索引：**将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据；**非聚簇索引：**将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置。
4. MyISAM 只支持表锁，而 InnoDB 还支持行锁；
5. InnoDB 不保存表的具体行数，执行`select count(*) from table` 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。

### 3. MySQL索引

#### 分类

从数据结构角度分类：

1. [B+ 树索引](#b+树)
2. [Hash 索引](#hashIndex)
3. [全文索引（Full-Text）](#fullTextIndex)
4. [空间索引（R-Tree）](#RTreeIndex)

从逻辑角度分类：

- 主键索引：主键索引是一种特殊的唯一索引，不允许有空值。
- 普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引。
- 多列索引（复合索引、联合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合。
- 唯一索引或者非唯一索引。
- 空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建。

从物理存储角度分类：

​	聚簇索引和非聚簇索引

##### <span id="b+树">B+ 树索引</span>

是大多数 MySQL 存储引擎的默认索引类型。

因为不再需要进行全表扫描，只需要对树进行搜索即可， 所以查找速度快很多。

因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。

可以指定多个列作为索引列，多个索引列共同组成键。

适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。

**主键索引与辅助索引结构**

<div style="display:flex; text-align:center;">
    <div style="flex:1;">
        <img src="https://gitee.com/coldsun233/NotePic/raw/master/img/InnoDB%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95.jpg" style="zoom:80%;" />
    </div>
    <div style="flex:1;">
        <img src="https://gitee.com/coldsun233/NotePic/raw/master/img/MyISAM%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95.jpg" style="zoom:80%;" />
    </div>
</div>

- **InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录**，对于主索引，此处会存放表中所有的数据记录；对于辅助索引此处会引用主键，检索的时候通过主键到主键索引中找到对应数据行，因此通过辅助索引进行条件搜索需要两个步骤：(1)在辅助索引上检索相关条件，到达其叶子节点获取对应的主键；(2)使用主键在主索引上再进行对应的检索操作。这就是所谓的”回表查询“。

    **辅助索引的叶子节点存储的是主键值，是为了保证数据一致性和节省存储空间**。如果辅助索引的叶子节点也存放的是实际数据，那么当数据发生更改的时候，需要修改多次，而且数据存储了多次很浪费空间。

- MyISAM引擎的索引文件和数据文件是分离的。**MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址**。MyISAM的主索引与辅助索引区别并不大，只是主键索引不能有重复的关键字。通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。辅助索引类似。

##### <span id="hashIndex">hash索引</span>

哈希索引能以 O(1) 时间进行查找，但是失去了有序性：

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

##### <span id="fullTextIndex">全文索引</span>

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。

查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

##### <span id="RTreeIndex">空间索引</span>

MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

#### 索引的优化

1. 独立的列

    在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

    例如下面的查询不能使用 actor_id 列的索引：

	```sql
	SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
	```

2. 多列索引

    在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。

    ```sql
    SELECT film_id, actor_ id FROM sakila.film_actor
    WHERE actor_id = 1 AND film_id = 1;
    ```

3. 索引列的顺序

    让选择性最强的索引列放在前面。

    索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。

    例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。

    ```sql
    SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
    COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
    COUNT(*)
    FROM payment;
       staff_id_selectivity: 0.0001
    customer_id_selectivity: 0.0373
                   COUNT(*): 16049
    ```

4. 前缀索引

    对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。

    前缀长度的选取需要根据索引选择性来确定。

5. 覆盖索引

    **覆盖索引**（Covering Index）,或者叫索引覆盖， 也就是平时所说的不需要回表操作。就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说**查询列要被所建的索引覆盖**。

    具有以下优点：

    - 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
    - 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
    - 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

#### 相关问题

1. 为什么 MySQL 索引使用 B+ 树而不是 B 树？
    - **B+树的磁盘读写代价更低**：InnoDB 在把磁盘数据读入到内存时会以页为基本单位，页的大小是固定的，非叶子节点存储数据信息会使得每一个节点（即一个页）能存储的 key 的数量减少，从而使得树的深度增大，增大查询时的磁盘I/O次数，进而影响查询效率。
    - **B+树的查询效率更加稳定：B+树任何关键字的查找必须走一条从根结点到叶子结点的路，所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。**
    
2. 为什么不采用 Hash 的方式？

    使用 Hash 的方式，多个数据在存储关系上是完全没有任何顺序关系的，对于区间查询是无法直接通过索引查询的，就需要全表扫描，所以哈希索引只适用于等值查询的场景；因为存在哈希碰撞的问题，如果有大量重复键值的情况下，哈希索引的效率会很低。

### 4. 查询优化

#### 使用 Explain 进行分析

使用 **Explain** 关键字可以模拟优化器执行SQL查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈

使用方式 Explain + sql语句，例如：

```sql
EXPLAIN SELECT column1, column2 FROM tablename WHERE id=1;
```

使用 Explain 会展示的信息：

<img src="https://gitee.com/coldsun233/NotePic/raw/master/img/explain.png" style="zoom:100%;" />

比较重要的字段有：

- select_type : 查询类型，有简单查询、联合查询、子查询等
- key : 使用的索引
- rows : 扫描的行数

#### 优化数据访问

1. 减少请求的数据量
    - 只返回必要的列：最好不要使用 SELECT * 语句。
    - 只返回必要的行：使用 LIMIT 语句来限制返回的数据。
    - 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。

2. 减少服务器端扫描的行数

    最有效的方式是使用索引来覆盖查询。

#### 重构查询方式

1. 切分大查询

    一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。

    ```sql
    DELETE FROM messages WHERE create < DATE_SUB(NOW(), INTERVAL 3 MONTH);
    rows_affected = 0
    do {
        rows_affected = do_query(
        "DELETE FROM messages WHERE create  < DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")
    } while rows_affected > 0
    ```

2. 分解大连接查询

    将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：

    - 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。
    - 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。
    - 减少锁竞争；
    - 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。
    - 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。

    ```sql
    SELECT * FROM tag
    JOIN tag_post ON tag_post.tag_id=tag.id
    JOIN post ON tag_post.post_id=post.id
    WHERE tag.tag='mysql';
    ```

    ```sql
    SELECT * FROM tag WHERE tag='mysql';
    SELECT * FROM tag_post WHERE tag_id=1234;
    SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);
    ```

### 5. 数据类型

#### 整型

包含 BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT

TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。

INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。

#### 浮点型

包含 FLOAT、DOUBLE、DECIMAL

FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAL 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。

FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。

<img src="https://gitee.com/coldsun233/NotePic/raw/master/img/MySQL%E6%95%B4%E5%9E%8B%E5%92%8C%E6%B5%AE%E7%82%B9%E5%9E%8B.webp" style="zoom:67%;" />

#### 字符串类型

包含 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB

char是固定长度，varchar长度可变。存储时，前者不管实际存储数据的长度，直接按 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的存储空间。

char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。

在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。

BLOB 与 TEXT 的区别：

- BLOB是一个二进制对象，可以容纳可变数量的数据。有四种类型的 BLOB：TINYBLOB、BLOB、MEDIUMBLOB和 LONGBLOB

- TEXT是一个不区分大小写的BLOB。四种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。

- BLOB 保存二进制数据，TEXT 保存字符数据。

<img src="https://gitee.com/coldsun233/NotePic/raw/master/img/MySQL%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B.webp" style="zoom:67%;" />

#### 时间日期类型

包含 Date、DateTime、TimeStamp、Time、Year

MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。

1. DATETIME

    能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。它**与时区无关**。

    默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。

2. TIMESTAMP

    和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。

    它**和时区有关**，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。

    MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。

    默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。

应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。

<img src="https://gitee.com/coldsun233/NotePic/raw/master/img/MySQL%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B.webp" style="zoom:67%;" />

#### 其他数据类型

包含：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等。

### 6. MySQL分表

#### 垂直拆分

垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

垂直拆分的优点： 可以使得列数据变⼩，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护；
垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应⽤层进⾏Join来解决。此外，垂直分区会让事务变得更加复杂。

#### 水平拆分

水平拆分，又称为数据分片，是把一个表复制成同样表结构的不同表，然后把数据按照一定的规则划分，分别存储到这些表中，从而保证单表的容量不会太大，提升性能；当然这些结构一样的表，可以放在一个或多个数据库中。

水平拆分的策略：

- 使用MD5哈希，做法是对UID进行md5加密，然后取前几位（我们这里取前两位），然后就可以将不同的UID哈希到不同的用户表（user_xx）中了。
- 根据时间放入不同的表，比如：article_201601，article_201602。
- 根据ID的值放入对应的表，第一个表user_0000，第二个100万的用户数据放在第二 个表user_0001中，随用户增加，直接添加用户表就行了。

### 7. 主从复制

<img src="https://gitee.com/coldsun233/NotePic/raw/master/img/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.webp" style="zoom:45%;" />

主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。

- **binlog 线程** ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
- **I/O 线程** ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。
- **SQL 线程** ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。

步骤：

1. master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；
2. salve 将 master 的 binary log events 拷贝到它的中继日志（relay log）;
3. slave 重做中继日志中的事件，将改变应用到自己的数据库中。MySQL 复制是异步且是串行化的。

**读写分离**

主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

读写分离能提高性能的原因在于：

- 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
- 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
- 增加冗余，提高可用性。

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

<!-- 分页-->

<div style="page-break-after: always;"></div>

<!--分页-->

## SQL

#### SQL 的执行顺序

[参考链接](https://blog.csdn.net/u014044812/article/details/51004754)

1. from 
2. join 
3. on 
4. where 
5. group by(开始使用select中的别名，后面的语句中都可以使用)
6.  avg,sum.... (聚集函数)
7. with {CUBE|ROLLUP}
8. having 
9. select 
10. distinct 
11. order by
12. limit

**所有的查询语句都是从from开始执行的，在执行过程中，每个步骤都会为下一个步骤生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入**。

执行过程：

1. 首先对from子句中的前两个表执行一个笛卡尔乘积，此时生成虚拟表 vt1（选择相对小的表做基础表）。 

2. 接下来便是应用 on 筛选器，on 中的逻辑表达式将应用到 vt1 中的各个行，筛选出满足 on 逻辑表达式的行，生成虚拟表 vt2。

3. 如果是outer join 那么这一步就将添加外部行，left outer join 就把左表在第二步中过滤的添加进来，如果是right outer join 那么就将右表在第二步中过滤掉的行添加进来，这样生成虚拟表 vt3。

4. 如果 from 子句中的表数目多余两个表，那么就将 vt3 和第三个表连接从而计算笛卡尔乘积，生成虚拟表，该过程就是一个重复1-3的步骤，最终得到一个新的虚拟表 vt3。

5. 对上一步生产的虚拟表引用where筛选器，生成虚拟表 vt4。

6. group by 子句将中的唯一的值组合成为一组，得到虚拟表 vt5。**如果应用了group by，那么后面的所有步骤都只能得到的vt5 的列或者是聚合函数（count、sum、avg等）。原因在于最终的结果集中只为每个组包含一行。**这一点请牢记。

7. 应用 cube 或者 rollup 选项，为 vt5 生成超组，生成 vt6。

8. 应用 having 筛选器，生成 vt7。**having 筛选器是第一个也是为唯一一个应用到已分组数据的筛选器**。

9. 处理 select 子句。将 vt7 中的在select中出现的列筛选出来生成 vt8。

10. 应用 distinct 子句，vt8 中移除相同的行，生成 vt9。事实上如果应用了group by子句那么 distinct 是多余的，原因在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。

11. 应用order by子句。按照order_by_condition排序vt9，此时返回的一个游标，而不是虚拟表。sql是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。对表进行排序的查询可以返回一个对象，这个对象包含特定的物理顺序的逻辑组织。这个对象就叫游标。正因为返回值是游标，那么使用 order by 子句查询不能应用于表达式。

12. 应用top选项。此时才返回结果给请求者即用户。MySQL 的 LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。**如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)**。

    > 在这有个比较重要的细节，对于包含 outer join 子句的查询，到底在 on 筛选器还是用 where 筛选器指定逻辑表达式呢？==on 和 where 的最大区别在于，如果在 on 应用逻辑表达式那么在第三步 outer join 中还可以把移除的行再次添加回来，而 where 的移除是最终的==。举个简单的例子，有一个学生表（班级,姓名）和一个成绩表（姓名,成绩），我现在需要返回一个 x 班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。为了得到我们预期的结果我们就需要在 on 子句指定学生和成绩表的关系（学生.姓名=成绩.姓名）那么在执行第二步的时候，对于没有参加考试的学生记录就不会出现在 vt2 中，因为他们被 on 的逻辑表达式过滤掉了，但是我们用 left outer join 就可以把左表（学生）中没有参加考试的学生找回来，因为我们想返回的是 x 班级的所有学生，如果在 on 中应用学生.班级='x'的话，left outer join 会把不是 x 班级的所有学生记录找回，所以只能在where筛选器中应用学生.班级='x' 因为它的过滤是最终的。

    例如：

    <div style="display:flex;text-align:center;">
        <div style="flex:1;">
            <img src="https://gitee.com/coldsun233/NotePic/raw/master/img/table1.png" style="zoom:100%;" />
        </div>
        <div style="flex:1;">
            <img src="https://gitee.com/coldsun233/NotePic/raw/master/img/table2.png" style="zoom:100%;" />
        </div>
    </div>

    

    <div style="display:flex; text-align:center;">
        <div style="flex:1">
            <img src="https://gitee.com/coldsun233/NotePic/raw/master/img/result1.png" style="zoom:100%;" />
        </div>
        <div style="flex:1">
            <img src="https://gitee.com/coldsun233/NotePic/raw/master/img/result2.png" style="zoom:100%;" />
        </div>
    </div>

    <img src="https://gitee.com/coldsun233/NotePic/raw/master/img/result3.png" style="zoom:100%;" />

### 索引的创建、删除和修改

- 创建：

  - 创建索引：`CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length));`

    如果是 CHAR，VARCHAR 类型，length 可以小于字段实际长度；如果是 BLOB 和 TEXT 类型，必须指定 length。

  - 修改表结构(添加索引)：`ALTER table tableName ADD [UNIQUE] INDEX indexName(columnName)`

- 删除：`DROP INDEX [indexName] ON mytable;`

- 查看：`SHOW INDEX FROM table_name\G`       --可以通过添加 \G 来格式化输出信息。

- 使用 ALERT 命令

  - ALTER TABLE tablename ADD PRIMARY KEY (column_list):` 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。
  - `ALTER TABLE tbl_name ADD UNIQUE index_name (column_list` 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。
  - `ALTER TABLE tbl_name ADD INDEX index_name (column_list)` 添加普通索引，索引值可出现多次。
  - `ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)`该语句指定了索引为 FULLTEXT ，用于全文索引。



